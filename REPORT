# NOT REALLY A REPORT BUT YEAH
- Learning: Python (Mainly): Learn it on W3S website:
                             syntax, variable, 
                             datatypes: string, integer, list, tuple, set, dict, bool, ......
                             if else, loop (quite easy as it has been introduced in C course)
                             function, lambda
                             classes, objects, inheritance, iterators
                             modules
                             and some minor thing about basic python
            NumPy (Just have learnt few of them): I mean, NumPy is Numerical Python that works with number in Python, great when coping with something complex like AI training. And it is used to work with arrays.
  Those will be written below (Just the examples code I wrote when I wanted to check something, so it do not really need to be read)
- Opinion and contributions to the group's project: 
  Still think it's a hard challenge. As we have diccussed, we have one week, start from 07/10/2024 to read and have some dicussions about the topic. So, just continue the progress. 

# LIST 
# ordered, changeable, allow duplicate
list = ["a", "b", "c", "c"]
list1 = ["a", "b", "c", "d"]
tuple1 = ("a", "b", "c", "d")
list2 = [1, 2, 2]
print(list)
print(list[0])
print(len(list))
list[1] = "a"
print(list)

list.insert(2, "added1") # add "added1" to the index 2
list.append("added2") # add "added2" to the end of the list
list.extend(list2) # add list2 to the end of the list
list.remove("c") # remove "c"
list.pop(3) # equavilent to del list[3]
list.pop() # remove the last item
print(list)

del list[3] # delete the 3 index
print(list)
list.clear() # clear the content, the list is still there but no content
del list # delete the whole list, ate and left no crumbs
print(list)

list3 = list1 # changes made in list1 will be transfered to list3
print(list3)

list4 = list1.copy() # changes made in list1 will not affect list4
print(list4)a
list5 = list(list1) # changes made in list1 will not affect list5
print(list5)

list6 = list1 + list2
print(list6)

# LIST 
# ordered, changeable, allow duplicate
list = ["a", "b", "c", "c"]
list1 = ["a", "b", "c", "d"]
tuple1 = ("a", "b", "c", "d")
list2 = [1, 2, 2]
print(list)
print(list[0])
print(len(list))
list[1] = "a"
print(list)

list.insert(2, "added1") # add "added1" to the index 2
list.append("added2") # add "added2" to the end of the list
list.extend(list2) # add list2 to the end of the list
list.remove("c") # remove "c"
list.pop(3) # equavilent to del list[3]
list.pop() # remove the last item
print(list)

del list[3] # delete the 3 index
print(list)
list.clear() # clear the content, the list is still there but no content
del list # delete the whole list, ate and left no crumbs
print(list)

list3 = list1 # changes made in list1 will be transfered to list3
print(list3)

list4 = list1.copy() # changes made in list1 will not affect list4
print(list4)a
list5 = list(list1) # changes made in list1 will not affect list5
print(list5)

list6 = list1 + list2
print(list6)

# SORT FOR LIST
list1 = ["e", "b", "C", "d"]
list2 = [3, 50, 2, 100]
tuple1 = ("a", "b", "c", "d")

list2.sort()
print(list2)
list2.sort(reverse = True)
print(list2)

def myfunc(n):
    return abs(n-3)

list2.sort(key = myfunc)
print(list2)

list1.sort()
print(list1)
list1.sort(key = str.upper)
print(list1)

list1.reverse()
print(list1)                 

# TUPLE
# ordered, unchangeable, allow duplicate 
tuple1 = ("a", "b", "c", "c")
print(tuple1)

tuple2 = ("a", 1, True)
print(tuple2)

print(tuple1[-3]) # third last item
print(tuple1[0:2]) # index 0 to 1

(x, y, *z) = tuple1
(a, *b, c) = tuple1
print(x, y, z)
print(a, b, c)

# SET 
# unordered, unchangeable, unindexed

set1 = {"a", "b", "c", "d", 1, 2 , False}
set1.add(True)
print(set1)

set2 = {5, 6, 7}
set1.update(set2)
print(set1)

set3 = set1.union(set2)
print(set3)
set3 = set1 | set2
print(set3)

set4 = {10}
set4.update(set1)
print(set4)

set5 = set1.intersection(set4)
print(set5)
set5 = set1 & set4
print(set5)

set6 = set1.difference(set4)
print(set6)
set6 = set1 - set4
print(set6)

set7 = set1.symmertric_difference(set2)
print(set7)
set7 = set1 ^ set2
print(set7)

# DICTIONARIES
# oredered (Python 3.7+)
# unordered (Python 3.6-)
# dictionary = keys + values
dict1 = {
    "text": "Hello",
    "Num" : 125,
    "Bool": True,
    "colors": ["red", "white"]
}
print(dict1)

x = dict1["colors"]
x = dict1.get("colors")
print(x)

print(dict1.keys())
print(dict1.values())
print(dict1.items())

dict1.update({"Num": 50})
dict1.update({"Update": 66})
dict1.pop("Num")
dict1.popitem() # remove the last inserted items
print(dict1)

for x, y in dict1.items():
    print(x, y)

dict2 = dict1.copy()
dict2 = dict(dict1)
print(dict2)

del dict1["Bool"]
dict1.clear()
print(dict1)

# NESTED DICTIONARY
myfamily = {
  "child1" : {
    "name" : "Emily",
    "year" : 2004
  },
  "child2" : {
    "name" : "Tobias",
    "year" : 2007
  },
  "child3" : {
    "name" : "Linus",
    "year" : 2011
  }
}

print(myfamily["child2"]["name"])

for x, obj in myfamily.items():
    print(x)
    
    for y in obj:
        print(y + ':', obj[y])

a = 1
b = 3

if (a > b):
    print("a>b")
elif (a == b):
    print("a=b")
else:
    print("a<b")

print("yes") if a < b else print("no")

if a < b and a + 2 == b:
    print("OK")
    
if not a > b:
    print("a<=b")
    pass

for i in range(5):
    if(i%2 == 1):
        continue
    print(i)
    
for i in range(2, 10, 3): #increment value by 3
    print(i)

def func():
    print("HI")

def func2(fname):
    print(fname + "?")
func2("Tom")

def func3(*name):
    print("There are " + name[2]) # taking the second name that is put into the function

func3("Tom", "Mai", "Quan", "Kien", "Bao")

def func4(**name):
    print("His name is " + name["lname"])

func4(fname = "Tom", lname = "Quan", sname = "Duong")

# LAMBDA
x = lambda a : a + 10
print(x(5))

x = lambda a, b, c : a*b+c
print(x(1, 2, 3))

class test:
    x = 5
    y = 10

p1 = test()
print(p1.x)
print(p1.y)

class person:
    def __init__(name, age, school):
        name.age = age
        name.school = school
    
    def __str__ (name, age, school):
        return f"{name.age}({name.school})"
        
p2 = person(90, "HSGS")
print(p2.age)
print(p2.school)

class child(person): # the child class will inherit all the properties and methods from the person class
    def __init__ (name, age, school, grade): # this def will overrides the person's innit()
        person.__init__(name, age, school)
        super().__init__(age, school)
        name.grade = grade
    
    def wel(name):
        print("HI", name.age, name.school, name.grade)

p3 = child(100, "HUST", 8)
print(p3.age)
print(p3.school)
print(p3.grade)

child.wel(p3)

# ITERATORS
tuple1 = ("a", "b", "c", "d")
myit = iter(tuple1)

print(next(myit))
print(next(myit))
print(next(myit))

string1 = "ABCdef"
mystr = iter(string1)
print(next(mystr))
print(next(mystr))

for x in mystr: # the loop is actually creates an iterator object and do the next() function
    print(x)

class num:
    def __iter__ (name):
        name.a = 1 
        return name
    
    def __next__ (name):
        if(name.a <= 20):
            x = name.a
            name.a += 1 
            return x
        else:
            raise StopIteration

myclass = num()
myit = iter(myclass)

print(next(myit))
print(next(myit))
print(next(myit))
print(next(myit))

for x in myit:
    print(x)

def greeting(name):
    print("Hello", name)
# save the file with a name, like: module.py 

import module

module.greeting("QUAN")

import module as mx 
x = dir(module) # list all the functions' name

import datetime
h = datetime.datetime.now()

import math
y = math.sqrt(64)
print(y)
pi = math.pi
print(x)

# RegEx
import re 
txt = "The rain in Spain"

x = re.search("^The.*Spain$", txt)
print(x)

y = re.findall("ai", txt)
print(y)

z = re.split("\s", txt)
print(z)

# NumPy
import numpy as np 
arr = np.array((1, 2, 3, 4, 5))
print(arr)
print(type(arr))

print(np.__version__)

brr = np.array(((1, 2/5 , 3, 4, 5), (6, 7, 8, 9, 10)))
crr = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])
drr = np.array((1,2), ndmin = 5) # set the dimension of drr to 5
print(brr)
print(crr)
print(type(brr))
print(brr.ndim) # check the number of dimensions of the array
print(drr.ndim)

print(arr[0:2:5])
print(brr[0,1])
print(brr[1, 0:3])
print(brr[0:2, 1:3])

print(brr.dtype) # check data type
eff = np.array((1, 2), dtype = 'i4') # data type 4 bytes integer

fff = arr.copy() # changes in arr do not affect fff
gff = arr.view() # changes in arr affect gff, vice versa
